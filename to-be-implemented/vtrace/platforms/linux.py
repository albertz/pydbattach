"""
Linux Platform Module
"""
# Copyright (C) 2007 Invisigoth - See LICENSE file for details
import os
import struct
import signal
import traceback
import platform

import vtrace
import vtrace.breakpoints as breakpoints
import vtrace.platforms.posix as v_posix
from vtrace.platforms.base import UtilMixin

import types

from ctypes import *
import ctypes.util as cutil

libc = CDLL(cutil.find_library("c"))

O_RDWR = 2
O_LARGEFILE = 0x8000

MAP_ANONYMOUS = 0x20
MAP_PRIVATE = 0x02

# Linux specific ptrace extensions
PT_GETREGS = 12
PT_SETREGS = 13
PT_GETFPREGS = 14
PT_SETFPREGS = 15
PT_ATTACH = 16
PT_DETACH = 17
PT_GETFPXREGS = 18
PT_SETFPXREGS = 19
PT_SYSCALL = 24
PT_SETOPTIONS = 0x4200
PT_GETEVENTMSG = 0x4201
PT_GETSIGINFO = 0x4202
PT_SETSIGINFO = 0x4203
# PT set options stuff.  ONLY TRACESYSGOOD may be used in 2.4...
PT_O_TRACESYSGOOD   = 0x00000001 # add 0x80 to TRAP when generated by syscall
# For each of the options below, the stop signal is (TRAP | PT_EVENT_FOO << 8)
PT_O_TRACEFORK      = 0x00000002 # Cause a trap at fork
PT_O_TRACEVFORK     = 0x00000004 # Cause a trap at vfork
PT_O_TRACECLONE     = 0x00000008 # Cause a trap at clone
PT_O_TRACEEXEC      = 0x00000010 # Cause a trap at exec
PT_O_TRACEVFORKDONE = 0x00000020 # Cause a trap when vfork done
PT_O_TRACEEXIT      = 0x00000040 # Cause a trap on exit
PT_O_MASK           = 0x0000007f
# Ptrace event types (TRAP | PT_EVENT_FOO << 8) means that type
# when using GETEVENTMSG for most of these, the new pid is the data
PT_EVENT_FORK       = 1
PT_EVENT_VFORK      = 2
PT_EVENT_CLONE      = 3
PT_EVENT_EXEC       = 4
PT_EVENT_VFORK_DONE = 5
PT_EVENT_EXIT       = 6

# Used to tell some of the additional events apart
SIG_LINUX_SYSCALL = signal.SIGTRAP | 0x80
SIG_LINUX_CLONE = signal.SIGTRAP | (PT_EVENT_CLONE << 8)

class LinuxMixin:
    """
    The mixin to take care of linux specific platform traits.
    (mostly proc)
    """

    def initMixin(self):
        # Wrap reads from proc in our worker thread
        self.pthreads = [] # FIXME perhaps make this posix-wide not just linux eventually...
        self.threadWrap("platformAllocateMemory", self.platformAllocateMemory)
        self.threadWrap("getPtraceEvent", self.getPtraceEvent)
        self.threadWrap("platformReadMemory", self.platformReadMemory)
        if platform.release().startswith("2.4"):
            self.threadWrap("platformWait", self.platformWait)
        #self.threadWrap("platformWriteMemory", self.platformWriteMemory)
        self.threadWrap("doAttachThread", self.doAttachThread)
        self.nptlinit = False
        self.memfd = None

        self.initMode("Syscall", False, "Break On Syscalls")

    def platformExec(self, cmdline):
        pid = v_posix.PtraceMixin.platformExec(self, cmdline)
        self.pthreads = [pid,]
        self.setMeta("ExeName",self._findExe(pid))
        return pid

    def setupMemFile(self, offset):
        """
        A utility to open (if necissary) and seek the memfile
        """
        if self.memfd == None:
            self.memfd = libc.open("/proc/%d/mem" % self.pid, O_RDWR | O_LARGEFILE, 0755)

        addr = c_ulonglong(offset)
        x = libc.llseek(self.memfd, addr, 0)

    #FIXME this is intel specific and should probably go in with the regs
    def platformAllocateMemory(self, size, perms=vtrace.MM_RWX, suggestaddr=0):
        sp = self.getStackCounter()
        pc = self.getProgramCounter()

        # Xlate perms (mmap is backward)
        realperm = 0
        if perms & vtrace.MM_READ:
            realperm |= 1
        if perms & vtrace.MM_WRITE:
            realperm |= 2
        if perms & vtrace.MM_EXEC:
            realperm |= 4

        #mma is struct of mmap args for linux syscall
        mma = struct.pack("<6L", suggestaddr, size, realperm, MAP_ANONYMOUS|MAP_PRIVATE, 0, 0)

        regsave = self.getRegisters()

        stacksave = self.readMemory(sp, len(mma))
        ipsave = self.readMemory(pc, 2)

        SYS_mmap = 90

        self.writeMemory(sp, mma)
        self.writeMemory(pc, "\xcd\x80")
        self.setRegisterByName("eax", SYS_mmap)
        self.setRegisterByName("ebx", sp)
        self.syncRegs()

        try:
            # Step over our syscall instruction
            tid = self.getMeta("ThreadId", 0)
            self.platformStepi()
            os.waitpid(tid, 0)
            eax = self.getRegisterByName("eax")
            if eax & 0x80000000:
                raise Exception("Linux mmap syscall error: %d" % eax)
            return eax

        finally:
            # Clean up all our fux0ring
            self.writeMemory(sp, stacksave)
            self.writeMemory(pc, ipsave)
            self.setRegisters(regsave)

    def handleAttach(self):
        for tid in self.threadsForPid(self.pid):
            if tid == self.pid:
                continue
            self.attachThread(tid)
        v_posix.PosixMixin.handleAttach(self)

    def platformReadMemory(self, address, size):
        """
        A *much* faster way of reading memory that the 4 bytes
        per syscall allowed by ptrace
        """
        self.setupMemFile(address)
        # Use ctypes cause python implementation is teh ghey
        buf = create_string_buffer("\x00" * size)
        x = libc.read(self.memfd, addressof(buf), size)
        if x != size:
            raise Exception("reading from invalid memory %s (%d returned)" % (hex(address), x))
        # We have to slice cause ctypes "helps" us by adding a null byte...
        return buf.raw[:size]

    #def whynot_platformWriteMemory(self, address, data):
        """
        A *much* faster way of writting memory that the 4 bytes
        per syscall allowed by ptrace
        """
        self.setupMemFile(address)
        buf = create_string_buffer(data)
        size = len(data)
        x = libc.write(self.memfd, addressof(buf), size)
        if x != size:
            raise Exception("write memory failed: %d" % x)
        return x

    def _findExe(self, pid):
        exe = os.readlink("/proc/%d/exe" % pid)
        if "(deleted)" in exe:
            if "#prelink#" in exe:
                exe = exe.split(".#prelink#")[0]
            elif ";" in exe:
                exe = exe.split(";")[0]
            else:
                exe = exe.split("(deleted)")[0].strip()
        return exe

    def platformAttach(self, pid):
        self.pthreads = [pid,]
        self.setMeta("ThreadId", pid)
        if v_posix.ptrace(PT_ATTACH, pid, 0, 0) != 0:
            raise Exception("PT_ATTACH failed!")
        self.setupPtraceOptions(pid)
        self.setMeta("ExeName", self._findExe(pid))

    def platformPs(self):
        pslist = []
        for dname in os.listdir("/proc/"):
            try:
                if not dname.isdigit():
                    continue
                cmdline = file("/proc/%s/cmdline" % dname).read()
                cmdline = cmdline.replace("\x00"," ")
                if len(cmdline) > 0:
                    pslist.append((int(dname),cmdline))
            except:
                pass # Permissions...  quick process... whatev.
        return pslist

    def attachThread(self, tid, attached=False):
        self.doAttachThread(tid,attached=attached)
        self.setMeta("ThreadId", tid)
        self.fireNotifiers(vtrace.NOTIFY_CREATE_THREAD)

    def platformWait(self):
        # Blocking wait once...
        pid, status = os.waitpid(-1, 0x40000002)
        self.setMeta("ThreadId", pid)
        # Stop the rest of the threads... 
        # why is linux debugging so Ghetto?!?!
        if not self.stepping: # If we're stepping, only do the one
            for tid in self.pthreads:
                if tid == pid:
                    continue
                os.kill(tid, signal.SIGTRAP)
                os.waitpid(tid, 0x40000002)
        return status

    def platformContinue(self):
        cmd = v_posix.PT_CONTINUE
        if self.getMode("Syscall", False):
            cmd = PT_SYSCALL
        pid = self.getPid()
        sig = self.getMeta("PendingSignal", 0)
        # Only deliver signals to the main thread
        if v_posix.ptrace(cmd, pid, 0, sig) != 0:
            raise Exception("ERROR ptrace failed for tid %d" % pid)

        for tid in self.pthreads:
            if tid == pid:
                continue
            if v_posix.ptrace(cmd, tid, 0, 0) != 0:
                pass

    def platformStepi(self):
        self.stepping = True
        tid = self.getMeta("ThreadId", 0)
        if v_posix.ptrace(v_posix.PT_STEP, tid, 0, 0) != 0:
            raise Exception("ERROR ptrace failed!")

    def platformDetach(self):
        libc.close(self.memfd)
        for tid in self.pthreads:
            tid,v_posix.ptrace(PT_DETACH, tid, 0, 0)

    def doAttachThread(self, tid, attached=False):
        """
        Do the work for attaching a thread.  This must be *under*
        attachThread() so callers in notifiers may call it (because
        it's also gotta be thread wrapped).
        """
        if not attached:
            if v_posix.ptrace(PT_ATTACH, tid, 0, 0) != 0:
                raise Exception("ERROR ptrace attach failed for thread %d" % tid)
        os.waitpid(tid, 0x40000002)
        self.setupPtraceOptions(tid)
        self.pthreads.append(tid)

    def setupPtraceOptions(self, tid):
        """
        Called by doAttachThread to setup ptrace related options.
        """
        opts = PT_O_TRACESYSGOOD
        if platform.release().startswith("2.6"):
            opts |= PT_O_TRACECLONE
        x = v_posix.ptrace(PT_SETOPTIONS, tid, 0, opts)
        if x != 0:
            print "WARNING ptrace SETOPTIONS failed for thread %d (%d)" % (tid,x)

    def threadsForPid(self, pid):
        ret = []
        tpath = "/proc/%s/task" % pid
        if os.path.exists(tpath):
            for pidstr in os.listdir(tpath):
                ret.append(int(pidstr))
        return ret

    def platformProcessEvent(self, status):
        # Skim some linux specific events before passing to posix
        tid = self.getMeta("ThreadId", -1)
        if os.WIFSTOPPED(status):
            sig = status >> 8
            if sig == SIG_LINUX_SYSCALL:
                self.fireNotifiers(vtrace.NOTIFY_SYSCALL)

            elif sig == SIG_LINUX_CLONE:
                # Handle a new thread here!
                newtid = self.getPtraceEvent()
                self.attachThread(newtid, attached=True)

            #FIXME eventually implement child catching!
            else:
                self.handlePosixSignal(sig)

            return

        v_posix.PosixMixin.platformProcessEvent(self, status)

    def getPtraceEvent(self):
        """
        This *thread wrapped* function will get any pending GETEVENTMSG
        msgs.
        """
        p = c_ulong(0)
        tid = self.getMeta("ThreadId", -1)
        if v_posix.ptrace(PT_GETEVENTMSG, tid, 0, byref(p)) != 0:
            raise Exception("ptrace PT_GETEVENTMSG failed! %d" % x)
        return p.value

    def platformGetRegs(self):
        x = (c_char * 512)()
        tid = self.getMeta("ThreadId", self.getPid())
        if v_posix.ptrace(PT_GETREGS, tid, 0, addressof(x)) != 0:
            raise Exception("ERROR ptrace PT_GETREGS failed for TID %d" % tid)
        return x.raw

    def platformGetThreads(self):
        ret = {}
        for tid in self.pthreads:
            ret[tid] = tid #FIXME make this pthread struct or stackbase soon
        return ret

    def platformGetMaps(self):
        self.requireAttached()
        maps = []
        mapfile = file("/proc/%d/maps" % self.pid)
        for line in mapfile:

            perms = 0
            sline = line.split(" ")
            addrs = sline[0]
            permstr = sline[1]
            fname = sline[-1].strip()
            addrs = addrs.split("-")
            base = long(addrs[0],16)
            max = long(addrs[1],16)
            mlen = max-base

            if "r" in permstr:
                perms |= vtrace.MM_READ
            if "w" in permstr:
                perms |= vtrace.MM_WRITE
            if "x" in permstr:
                perms |= vtrace.MM_EXEC
            #if "p" in permstr:
                #pass

            maps.append((base,mlen,perms,fname))
        return maps

    def platformGetFds(self):
        fds = []
        for name in os.listdir("/proc/%d/fd/" % self.pid):
            try:
                fdnum = int(name)
                fdtype = vtrace.FD_UNKNOWN
                link = os.readlink("/proc/%d/fd/%s" % (self.pid,name))
                if "socket:" in link:
                    fdtype = vtrace.FD_SOCKET
                elif "pipe:" in link:
                    fdtype = vtrace.FD_PIPE
                elif "/" in link:
                    fdtype = vtrace.FD_FILE

                fds.append((fdnum,fdtype,link))
            except:
                traceback.print_exc()

        return fds

class LinuxIntelRegisters:
    """
    The actual trace object for IntelLinux, which inherits
    what it can from IntelMixin/LinuxMixin and implements
    what is must.

    The size of the linux user area struct is 284 bytes...

    """

    def initMixin(self):
        self.usize = 284

    def maybeCalcUserSize(self):
        """
        LOL... this works actually... but we're not using it...
        """
        if self.usize != 0:
            return
        tid = self.getMeta("ThreadId", self.getPid())
        val = -1
        off = 500
        while val == -1:
            off -= 4
            val = v_posix.ptrace(v_posix.PT_READ_U, tid, off, 0)
            if off == 0:
                return
        self.usize = off + 4

    def platformGetRegs(self):
        """
        Start with what's given by PT_GETREGS and pre-pend
        the debug registers
        """
        tid = self.getMeta("ThreadId", self.getPid())
        buf = LinuxMixin.platformGetRegs(self)
        dbgs = []
        off = self.usize - 32
        for i in range(8):
            r = v_posix.ptrace(v_posix.PT_READ_U, tid, off+(4*i), 0)
            dbgs.append(r & 0xffffffff)

        return struct.pack("8L", *dbgs) + buf

    def platformSetRegs(self, buf):
        """
        Reverse of above...
        """
        tid = self.getMeta("ThreadId", self.getPid())

        x = create_string_buffer(buf[32:])
        if v_posix.ptrace(PT_SETREGS, tid, 0, addressof(x)) != 0:
            raise Exception("ERROR ptrace PT_SETREGS failed!")

        dbgs = struct.unpack("8L", buf[:32])
        off = self.usize - 32
        for i in range(8):
            v_posix.ptrace(v_posix.PT_WRITE_U, tid, off+(4*i), dbgs[i])

    def getRegisterFormat(self):
        return "15L8H2L2H2L2H"

    def getRegisterNames(self):
        return (
            "debug0","debug1","debug2","debug3","debug4","debug5",
            "debug6","debug7",
            "ebx","ecx","edx","esi","edi","ebp","eax","ds","__ds",
            "es","__es","fs","__fs","gs","__gs","orig_eax","eip",
            "cs","__cs","eflags","esp","ss","__ss")

class LinuxAmd64Registers:
    """
    Mixin for the register format on Linux AMD64
    """
    def initMixin(self):
        pass

    def getRegisterFormat(self):
        return "27L"

    def getRegisterNames(self):
        return (
            "r15","r14","r13","r12","rbp","rbx","r11","r10",
            "r9","r8","rax","rcx","rdx","rsi","rdi","orig_rax",
            "rip","cs","eflags",
            "rsp","ss",
            "fs_base"," gs_base",
            "ds","es","fs","gs")

